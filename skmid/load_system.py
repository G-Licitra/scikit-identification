# %%
from signal import Sigmasks
from turtle import color

import casadi as ca
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from mpl_toolkits.mplot3d import Axes3D

from skmid.integrator import RungeKutta4
from skmid.models import DynamicModel
from skmid.models import generate_model_attributes


def lotka_volterra():

    # define states and parameters
    (states, _, param) = generate_model_attributes(state_size=2, parameter_size=4)

    # x, y,  number of prey (for example, rabbits), number of some predator (for example, foxes)
    x, y = states[0], states[1]

    # positive real parameters describing the interaction of the two species.
    alpha, beta, gamma, delta = param[0], param[1], param[2], param[3]

    # dx = f(states, param) <==> rhs = f(x, p)
    rhs = [alpha * x - beta * x * y, delta * x * y - gamma * y]

    output = [ca.fabs(x - y)]  # absolute value casadi operator

    model = DynamicModel(
        state=states,
        parameter=param,
        model_dynamics=rhs,
        output=output,
        state_name=["x", "y"],
        param_name=["alpha", "beta", "gamma", "delta"],
        output_name=["|x-y|"],
    )

    # invoke integrator
    rk4 = RungeKutta4(model=model, fs=10)

    # simulate with starting from 10 prey and 10 predators
    param_val = [2.0 / 3.0, 4.0 / 3.0, 1, 1]  # alpha, beta, gamma, delta

    _ = rk4.simulate(x0=[0.9, 1.8], param=param_val, N_steps=1000)

    # rk4.state_sim_.plot(x="x", y="y", title="Lotka-Volterra")

    description = (
        "Van der Pol oscillator: non-conservative oscillator with non-linear damping."
        "It evolves in time according to the differential equation:"
        "dx1/dt = mu*(1-x2^2)*x1 - x2"
        "dx2/dt = x1"
        "where mu is the damping coefficient, and x is the position coordinate."
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[-1, 1], param=4, N_steps=10000)"
        "Further details https://en.wikipedia.org/wiki/Van_der_Pol_oscillator"
    )

    return {
        "input_sim": None,
        "state_sim": rk4.state_sim_,
        "output_sim": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


def van_der_pol_oscillator():
    """model dx = f(x,p)
    nx = 2, np=1

    Returns:
        _type_: _description_
    """

    # define states and parameters
    (states, _, param) = generate_model_attributes(state_size=2, parameter_size=1)
    x1, x2 = states[0], states[1]
    mu = param[0]

    # dx = f(states, input) <==> rhs = f(x,u, p)
    rhs = [mu * (1 - x2**2) * x1 - x2, x1]
    model = DynamicModel(state=states, parameter=param, model_dynamics=rhs)

    # invoke integrator
    rk4 = RungeKutta4(model=model, fs=100)

    #
    _ = rk4.simulate(x0=[-1, 1], param=4, N_steps=10000)

    df_sim = rk4.state_sim_

    # df_sim.plot(x="x2", y="x1")

    description = (
        "Van der Pol oscillator: non-conservative oscillator with non-linear damping."
        "It evolves in time according to the differential equation:"
        "dx1/dt = mu*(1-x2^2)*x1 - x2"
        "dx2/dt = x1"
        "where mu is the damping coefficient, and x is the position coordinate."
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[-1, 1], param=4, N_steps=10000)"
        "Further details https://en.wikipedia.org/wiki/Van_der_Pol_oscillator"
    )

    return {
        "input_sim": None,
        "state_sim": rk4.state_sim_,
        "output_sim": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


def lorenz_system():

    # define states and parameters
    (states, _, _) = generate_model_attributes(state_size=3)
    x, y, z = states[0], states[1], states[2]

    sigma = 10
    rho = 28
    beta = 8.0 / 3.0

    # dx = f(states) <==> rhs = f(x)
    rhs = [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]
    model = DynamicModel(state=states, model_dynamics=rhs, state_name=["x", "y", "z"])

    # invoke integrator
    rk4 = RungeKutta4(model=model, fs=100)
    _ = rk4.simulate(x0=[1, 1, 1], N_steps=5000)

    # TODO: here we assign df_sim but we do not use it
    df_sim = rk4.state_sim_

    description = (
        "Lorenz attractor: The equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above. "
        "It evolves in time according to the differential equation:"
        "dx/dt = sigma * (y - x)",
        "dy/dt = x*(rho - z) - y," "dz/dt = x*y - beta*z",
        "where sigma=10, rho=20 and beta=8/3 are system parameter, x is proportional to the rate of convection,"
        "y to the horizontal temperature variation, and z to the vertical temperature variation.",
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[1, 1, 1], N_step9s=5000)"
        "Further details https://en.wikipedia.org/wiki/Lorenz_system",
    )

    return {
        "input_sim": None,
        "state_sim": rk4.state_sim_,
        "output_sim": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


def chua_circuit():

    # define states and parameters
    (states, _, _) = generate_model_attributes(state_size=3)
    x, y, z = states[0], states[1], states[2]

    alpha = 15.6
    beta = 28
    m0 = -1.143
    m1 = -0.714

    h = m1 * x + 0.5 * (m0 - m1) * (ca.fabs(x + 1) - ca.fabs(x - 1))

    dx = alpha * (y - x - h)
    dy = x - y + z
    dz = -beta * y

    # dx = f(states) <==> rhs = f(x)
    rhs = [dx, dy, dz]
    model = DynamicModel(state=states, model_dynamics=rhs, state_name=["x", "y", "z"])

    # invoke integrator
    rk4 = RungeKutta4(model=model, fs=100)
    _ = rk4.simulate(x0=[0.7, 0, 0], N_steps=1000)

    # TODO: here we assign df_sim but we do not use it
    df_sim = rk4.state_sim_

    description = (
        "Lorenz attractor: The equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above. "
        "It evolves in time according to the differential equation:"
        "dx/dt = sigma * (y - x)",
        "dy/dt = x*(rho - z) - y," "dz/dt = x*y - beta*z",
        "where sigma=10, rho=20 and beta=8/3 are system parameter, x is proportional to the rate of convection,"
        "y to the horizontal temperature variation, and z to the vertical temperature variation.",
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[1, 1, 1], N_steps=5000)"
        "Further details https://en.wikipedia.org/wiki/Lorenz_system",
    )

    return {
        "input_sim": None,
        "state_sim": rk4.state_sim_,
        "output_sim": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


def magnetic_levitation_system():

    # define states and parameters
    (states, input, _) = generate_model_attributes(state_size=3, input_size=1)

    p = states[0]  # x1 object position [m]
    v = states[1]  # x2 object velocity [m/s]
    i = states[2]  # x3 current [A]

    E = input[0]  # voltage [V]
    g0 = 9.81
    R = 50
    L = 0.5
    m = 0.02
    Km = 19.62
    b = 0.1

    ueq = 5
    xeq = [np.sqrt(Km / (m * g0)) * (ueq / R), 0, ueq / R]

    rhs = [
        v,
        g0 - (b / m) * v - (Km / m) * ((i / p) ** 2),
        (1 / (L + Km / p)) * (-R * i + Km * (v / (p**2)) + E),
    ]

    output = [p]  # measure position

    model = DynamicModel(
        state=states,
        input=input,
        model_dynamics=rhs,
        output=output,
        state_name=["position", "velocity", "current"],
        input_name=["Voltage"],
        output_name=["position"],
    )

    model.print_summary()

    rhs_num, y_num = model.evaluate(state_num=xeq, input_num=ueq)
    print(f"rhs = {rhs_num}, \ny = {y_num}")

    # invoke integrator
    rk4 = RungeKutta4(model=model, fs=100)

    # input test
    # input = ueq * np.ones((100, 1))
    input = (
        ueq * np.ones((1, 100)) + 3 * np.sin(2 * np.pi * 1 * np.linspace(0, 1, 100))
    ).T

    _ = rk4.simulate(x0=xeq, input=input)

    description = (
        "Lorenz attractor: The equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above. "
        "It evolves in time according to the differential equation:"
        "dx/dt = sigma * (y - x)",
        "dy/dt = x*(rho - z) - y," "dz/dt = x*y - beta*z",
        "where sigma=10, rho=20 and beta=8/3 are system parameter, x is proportional to the rate of convection,"
        "y to the horizontal temperature variation, and z to the vertical temperature variation.",
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[1, 1, 1], N_steps=5000)"
        "Further details https://en.wikipedia.org/wiki/Lorenz_system",
    )

    return {
        "time": rk4.time_,
        "input_vector": rk4.input_,
        "state_simulation": rk4.state_sim_,
        "output_simulation": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


def first_order_system():

    # define states and parameters

    (x, u, parameter) = generate_model_attributes(
        state_size=1, input_size=1, parameter_size=2
    )

    tau, kp = parameter[0], parameter[1]
    sys = DynamicModel(
        state=x,
        input=u,
        parameter=parameter,
        parameter_name=["tau", "kp"],
        model_dynamics=[-(1 / tau) * x + (kp / tau) * u],
    )

    parameter_num = [1, 1]
    rk4 = RungeKutta4(model=sys, fs=fs)
    _ = rk4.simulate(initial_condition=[0], input=df_input, parameter=parameter_num)

    df_X = rk4.state_sim_
    df_Y = rk4.output_sim_

    model = DynamicModel(
        state=x,
        input=u,
        model_dynamics=rhs,
        output=output,
        state_name=["position", "velocity", "current"],
        input_name=["Voltage"],
        output_name=["position"],
    )

    model.print_summary()

    rhs_num, y_num = model.evaluate(state_num=xeq, input_num=ueq)
    print(f"rhs = {rhs_num}, \ny = {y_num}")

    # invoke integrator
    rk4 = RungeKutta4(model=model, fs=100)

    # input test
    # input = ueq * np.ones((100, 1))
    input = (
        ueq * np.ones((1, 100)) + 3 * np.sin(2 * np.pi * 1 * np.linspace(0, 1, 100))
    ).T

    description = (
        "Lorenz attractor: The equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above. "
        "It evolves in time according to the differential equation:"
        "dx/dt = sigma * (y - x)",
        "dy/dt = x*(rho - z) - y," "dz/dt = x*y - beta*z",
        "where sigma=10, rho=20 and beta=8/3 are system parameter, x is proportional to the rate of convection,"
        "y to the horizontal temperature variation, and z to the vertical temperature variation.",
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[1, 1, 1], N_steps=5000)"
        "Further details https://en.wikipedia.org/wiki/Lorenz_system",
    )

    return {
        "time": rk4.time_,
        "input_vector": rk4.input_,
        "state_simulation": rk4.state_sim_,
        "output_simulation": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


def second_order_system():

    # define states and parameters
    (state, input, parameter) = generate_model_attributes(
        state_size=3, input_size=1, parameter_size=3
    )

    x1, x2 = state[0], state[1]
    u = input[0]

    Kp = parameter[0]  # Gain
    zeta = parameter[1]  # damping factor
    tau_s = parameter[2]  # second order time constant

    rhs = [
        x2,
        -(1 / tau_s**2) * x1 - (2 * zeta) / tau_s * x2 + (Kp / tau_s**2) * u,
    ]

    output = ["x1"]

    model = DynamicModel(
        state=state,
        input=input,
        parameter=parameter,
        model_dynamics=rhs,
        output=output,
        parameter_name=["Kp", "zeta", "tau_s"],
    )

    model.print_summary()

    rhs_num, y_num = model.evaluate(state_num=[0, 0], input_num=[0])
    print(f"rhs = {rhs_num}, \ny = {y_num}")

    initial_condition = [0, 0]

    # input = ueq * np.ones((100, 1))
    N = 500  # Number of samples
    fs = 500  # Sampling frequency [hz]
    t = np.linspace(0, (N - 1) * (1 / fs), N)
    df_input = pd.DataFrame(index=t).assign(
        step=lambda x: np.where(x.index < t[int(N / 4)], 0, 1)
    )

    rk4 = RungeKutta4(model=model, fs=fs)
    _ = rk4.simulate(initial_condition=initial_condition, input=df_input)

    description = (
        "Second Order System: TODO. "
        "The data are generated by RungeKutta4(model=model, fs=100).simulate(x0=[1, 1, 1], N_steps=5000)"
        "Further details https://apmonitor.com/pdc/index.php/Main/SecondOrderSystems",
    )

    return {
        "time": rk4.time_,
        "input_vector": rk4.input_,
        "state_simulation": rk4.state_sim_,
        "output_simulation": rk4.output_sim_,
        "model_function": model,
        "description": description,
    }


if __name__ == "__main__":
    """run for testing only"""

    # data = lotka_volterra()

    # data = van_der_pol_oscillator()

    # data = lorenz_system()

    # data = chua_circuit()

    # data = magnetic_levitation_system()

    data = second_order_system()

    # print("Done!")
